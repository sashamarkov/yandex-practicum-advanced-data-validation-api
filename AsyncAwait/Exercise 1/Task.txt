В этом тренажёре вам нужно выпускать котиков на волю, кликая по выделенной области. Котики весело разбегаются, а в этом им помогают промисы. Но за окном 21-й век, поэтому нужно переходить на синтаксис async/await. В этом задании вам не нужно добавлять код, чтобы тренажёр заработал. Тренажёр уже работает, но вам необходимо заменить все промисы на async/await, и тогда код станет проще и понятнее.

---
Переделайте все функции и коллбеки в async-формат
- Выделите переменные для return и для throw
- Помните о try .. catch
- Объедините промисы в список ожидания котиков с помощью локальной async-функции.

---
index.js

const container = document.querySelector(".container")

function addDiv(x, y) {
    return new Promise((resolve, reject) => {
        if(container.childNodes.length > 128){
            return reject("too many cats")
        }
        const newDiv = document.createElement('div');
        newDiv.classList.add('inner-div');

        newDiv.style.left = `${x}px`;
        newDiv.style.top = `${y}px`;

        resolve(newDiv)
    })
}

container.onclick = ev => {
    addDiv(ev.x, ev.y)
        .then(divElem => {
            divElem.textContent = "🐱"
            divElem.setAttribute("dx", (10 * Math.random() - 5))
            divElem.setAttribute("dy", (10 * Math.random() - 5))
            container.appendChild(divElem);
        })
        .catch(err => console.error("cant add cat", err))
}

function drawFrame(prevDate){
    let now = Date.now()
    let dt = Math.max(1, now - prevDate)
    let containerRect = container.getBoundingClientRect();
    let calcPromises = [];
    container.childNodes.forEach(node => {
        if(node instanceof Element && node.classList.contains("inner-div")){
            let calcPromise = new Promise((resolve, reject) => {
                let dx = parseFloat(node.getAttribute('dx'))
                let dy = parseFloat(node.getAttribute('dy'))
                node.style.left = `${parseFloat(node.style.left) + 10 * (dx * dt / 1000)}px`
                node.style.top = `${parseFloat(node.style.top) + 10 * (dy * dt / 1000)}px`

                let nodeRect = node.getBoundingClientRect();
                if(nodeRect.left > containerRect.right 
                    || nodeRect.right < containerRect.left
                    || nodeRect.bottom < containerRect.top
                    || nodeRect.top > containerRect.bottom) {
                    reject({err: "cat run away", node})
                } else {
                    resolve({node})
                }
            })
            calcPromises.push(calcPromise)
        }
    })
    Promise.allSettled(calcPromises).then(res => {
        res.filter (nodeRes => nodeRes.status == 'rejected')
            .forEach(nodeRes => container.removeChild(nodeRes.reason.node))
    }).then(() => requestAnimationFrame(() => drawFrame(now)))
}

document.addEventListener('DOMContentLoaded', () => {
    drawFrame(Date.now())
})